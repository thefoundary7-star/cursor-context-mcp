#!/usr/bin/env node

/**
 * Test script to verify the check_vulnerabilities implementation
 */

import { handleSecurityTool } from './src/tools/securityTools.js';
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

async function testVulnerabilityCheck() {
  console.log('üîç Testing Vulnerability Check Implementation');
  console.log('=============================================');
  
  try {
    // Test 1: Basic vulnerability check
    console.log('\n1Ô∏è‚É£ Testing Basic Vulnerability Check:');
    console.log('----------------------------------------');
    
    const basicResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'auto',
      severity: 'medium',
      includeDevDependencies: true,
      outputFormat: 'json'
    });
    
    console.log('‚úÖ Basic Vulnerability Check Result:');
    console.log(JSON.stringify(basicResult, null, 2));
    
    // Test 2: NPM-specific vulnerability check
    console.log('\n2Ô∏è‚É£ Testing NPM Vulnerability Check:');
    console.log('-------------------------------------');
    
    const npmResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'npm',
      severity: 'high',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ NPM Vulnerability Check Result:');
    console.log(JSON.stringify(npmResult, null, 2));
    
    // Test 3: High severity only
    console.log('\n3Ô∏è‚É£ Testing High Severity Only:');
    console.log('--------------------------------');
    
    const highSeverityResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'auto',
      severity: 'high',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ High Severity Only Result:');
    console.log(JSON.stringify(highSeverityResult, null, 2));
    
    // Test 4: Test with non-existent directory
    console.log('\n4Ô∏è‚É£ Testing Non-existent Directory:');
    console.log('------------------------------------');
    
    const nonExistentResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '/non/existent/path',
      packageManager: 'auto'
    });
    
    console.log('‚úÖ Non-existent Directory Result:');
    console.log(JSON.stringify(nonExistentResult, null, 2));
    
    // Test 5: Test with unsupported package manager
    console.log('\n5Ô∏è‚É£ Testing Unsupported Package Manager:');
    console.log('----------------------------------------');
    
    const unsupportedResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'maven'
    });
    
    console.log('‚úÖ Unsupported Package Manager Result:');
    console.log(JSON.stringify(unsupportedResult, null, 2));
    
    // Test 6: Test with all parameters
    console.log('\n6Ô∏è‚É£ Testing All Parameters:');
    console.log('-----------------------------');
    
    const allParamsResult = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'auto',
      severity: 'critical',
      includeDevDependencies: true,
      outputFormat: 'summary'
    });
    
    console.log('‚úÖ All Parameters Result:');
    console.log(JSON.stringify(allParamsResult, null, 2));
    
    console.log('\nüéâ All vulnerability check tests completed!');
    
  } catch (error) {
    console.error('‚ùå Test failed:', error.message);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  }
}

async function testVulnerabilityCheckWithTestFiles() {
  console.log('\nüß™ Testing Vulnerability Check with Test Files');
  console.log('===============================================');
  
  try {
    // Create test directory
    const testDir = './test-vulnerability-check';
    mkdirSync(testDir, { recursive: true });
    
    // Test 1: NPM project with vulnerabilities
    console.log('\nüì¶ Testing NPM Project with Vulnerabilities:');
    const npmDir = join(testDir, 'npm-project');
    mkdirSync(npmDir, { recursive: true });
    
    const packageJson = {
      "name": "test-npm-project",
      "version": "1.0.0",
      "dependencies": {
        "lodash": "^4.17.20",
        "express": "^4.18.0",
        "axios": "^0.21.0"
      },
      "devDependencies": {
        "jest": "^29.0.0",
        "typescript": "^4.9.0"
      }
    };
    writeFileSync(join(npmDir, 'package.json'), JSON.stringify(packageJson, null, 2));
    
    const npmResult = await handleSecurityTool('check_vulnerabilities', {
      directory: npmDir,
      packageManager: 'npm',
      severity: 'medium',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ NPM Project Result:');
    console.log(JSON.stringify(npmResult, null, 2));
    
    // Test 2: Python project with requirements.txt
    console.log('\nüêç Testing Python Project:');
    const pythonDir = join(testDir, 'python-project');
    mkdirSync(pythonDir, { recursive: true });
    
    const requirementsContent = `
requests>=2.25.0
numpy==1.21.0
pandas>=1.3.0
flask==2.0.0
`;
    writeFileSync(join(pythonDir, 'requirements.txt'), requirementsContent);
    
    const pythonResult = await handleSecurityTool('check_vulnerabilities', {
      directory: pythonDir,
      packageManager: 'pip',
      severity: 'high',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ Python Project Result:');
    console.log(JSON.stringify(pythonResult, null, 2));
    
    // Test 3: Rust project
    console.log('\nü¶Ä Testing Rust Project:');
    const rustDir = join(testDir, 'rust-project');
    mkdirSync(rustDir, { recursive: true });
    
    const cargoToml = `
[package]
name = "test-rust-project"
version = "0.1.0"

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }

[dev-dependencies]
criterion = "0.3"
`;
    writeFileSync(join(rustDir, 'Cargo.toml'), cargoToml);
    
    const rustResult = await handleSecurityTool('check_vulnerabilities', {
      directory: rustDir,
      packageManager: 'cargo',
      severity: 'medium',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ Rust Project Result:');
    console.log(JSON.stringify(rustResult, null, 2));
    
    // Test 4: Maven project (unsupported)
    console.log('\n‚òï Testing Maven Project (Unsupported):');
    const mavenDir = join(testDir, 'maven-project');
    mkdirSync(mavenDir, { recursive: true });
    
    const pomXml = `
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>test-maven-project</artifactId>
  <version>1.0.0</version>
  
  <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>5.3.0</version>
    </dependency>
  </dependencies>
</project>
`;
    writeFileSync(join(mavenDir, 'pom.xml'), pomXml);
    
    const mavenResult = await handleSecurityTool('check_vulnerabilities', {
      directory: mavenDir,
      packageManager: 'maven',
      severity: 'medium',
      includeDevDependencies: true
    });
    
    console.log('‚úÖ Maven Project Result:');
    console.log(JSON.stringify(mavenResult, null, 2));
    
    // Clean up test directory
    const { rmSync } = await import('fs');
    rmSync(testDir, { recursive: true, force: true });
    console.log('‚úÖ Test directory cleaned up');
    
  } catch (error) {
    console.error('‚ùå Test with files failed:', error.message);
    console.error('Stack trace:', error.stack);
  }
}

async function testVulnerabilityCheckParsing() {
  console.log('\nüîç Testing Vulnerability Check Parsing:');
  console.log('========================================');
  
  try {
    // Test with basic parameters
    const result = await handleSecurityTool('check_vulnerabilities', {
      directory: '.',
      packageManager: 'auto',
      severity: 'medium',
      includeDevDependencies: true
    });
    
    if (result.success && result.data) {
      console.log('‚úÖ Vulnerability Check Structure:');
      console.log(`- Manager: ${result.data.manager}`);
      console.log(`- Total vulnerabilities: ${result.data.summary?.total || 0}`);
      console.log(`- Directory: ${result.data.directory}`);
      console.log(`- Tool available: ${result.data.toolAvailable}`);
      
      if (result.data.summary?.bySeverity) {
        console.log('\nüîç Vulnerabilities by Severity:');
        Object.entries(result.data.summary.bySeverity).forEach(([severity, count]) => {
          if (count > 0) {
            console.log(`- ${severity}: ${count}`);
          }
        });
      }
      
      if (result.data.vulnerabilities && result.data.vulnerabilities.length > 0) {
        console.log('\nüìù Sample Vulnerabilities:');
        result.data.vulnerabilities.slice(0, 3).forEach((vuln, index) => {
          console.log(`${index + 1}. ${vuln.name}@${vuln.version} - ${vuln.severity}`);
          console.log(`   Advisory: ${vuln.advisory}`);
          console.log(`   Source: ${vuln.source}`);
        });
      }
    } else {
      console.log('‚ö†Ô∏è Vulnerability check failed:', result.error);
    }
    
  } catch (error) {
    console.error('‚ùå Vulnerability check parsing test failed:', error.message);
  }
}

async function testErrorHandling() {
  console.log('\nüö® Testing Error Handling:');
  console.log('===========================');
  
  try {
    // Test various error scenarios
    const errorTests = [
      {
        name: 'Non-existent directory',
        args: { directory: '/tmp/non-existent-vulnerability-test' }
      },
      {
        name: 'Unsupported package manager',
        args: { directory: '.', packageManager: 'maven' }
      },
      {
        name: 'Invalid severity',
        args: { directory: '.', severity: 'invalid' }
      },
      {
        name: 'Invalid output format',
        args: { directory: '.', outputFormat: 'invalid' }
      }
    ];
    
    for (const test of errorTests) {
      console.log(`\nüîß Testing ${test.name}:`);
      
      try {
        const result = await handleSecurityTool('check_vulnerabilities', test.args);
        
        if (result.success) {
          console.log(`‚úÖ ${test.name} - Success`);
        } else {
          console.log(`‚ö†Ô∏è ${test.name} - Failed as expected`);
          console.log(`   Error: ${result.error}`);
          console.log(`   Message: ${result.data?.message || 'No message'}`);
        }
      } catch (error) {
        console.log(`‚ùå ${test.name} - Exception`);
        console.log(`   Error: ${error.message}`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error handling test failed:', error.message);
  }
}

async function testSeverityFiltering() {
  console.log('\nüîç Testing Severity Filtering:');
  console.log('===============================');
  
  try {
    // Test different severity levels
    const severityTests = [
      { name: 'Low severity', severity: 'low' },
      { name: 'Medium severity', severity: 'medium' },
      { name: 'High severity', severity: 'high' },
      { name: 'Critical severity', severity: 'critical' }
    ];
    
    for (const test of severityTests) {
      console.log(`\nüîß Testing ${test.name}:`);
      
      try {
        const result = await handleSecurityTool('check_vulnerabilities', {
          directory: '.',
          packageManager: 'auto',
          severity: test.severity,
          includeDevDependencies: true
        });
        
        if (result.success) {
          console.log(`‚úÖ ${test.name} - Success`);
          console.log(`   Total vulnerabilities: ${result.data.summary?.total || 0}`);
          
          if (result.data.summary?.bySeverity) {
            const severityCounts = result.data.summary.bySeverity;
            console.log(`   Severity breakdown:`, severityCounts);
          }
        } else {
          console.log(`‚ö†Ô∏è ${test.name} - Failed: ${result.error}`);
        }
      } catch (error) {
        console.log(`‚ùå ${test.name} - Exception: ${error.message}`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Severity filtering test failed:', error.message);
  }
}

async function testToolAvailability() {
  console.log('\nüîß Testing Tool Availability:');
  console.log('==============================');
  
  try {
    // Test different package managers
    const managerTests = [
      { name: 'NPM', manager: 'npm' },
      { name: 'PIP', manager: 'pip' },
      { name: 'Cargo', manager: 'cargo' },
      { name: 'Maven', manager: 'maven' },
      { name: 'Gradle', manager: 'gradle' }
    ];
    
    for (const test of managerTests) {
      console.log(`\nüîß Testing ${test.name}:`);
      
      try {
        const result = await handleSecurityTool('check_vulnerabilities', {
          directory: '.',
          packageManager: test.manager,
          severity: 'medium',
          includeDevDependencies: true
        });
        
        if (result.success) {
          console.log(`‚úÖ ${test.name} - Success`);
          console.log(`   Manager: ${result.data.manager}`);
          console.log(`   Tool available: ${result.data.toolAvailable}`);
          console.log(`   Vulnerabilities: ${result.data.summary?.total || 0}`);
        } else {
          console.log(`‚ö†Ô∏è ${test.name} - Failed: ${result.error}`);
        }
      } catch (error) {
        console.log(`‚ùå ${test.name} - Exception: ${error.message}`);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Tool availability test failed:', error.message);
  }
}

async function main() {
  try {
    await testVulnerabilityCheck();
    await testVulnerabilityCheckWithTestFiles();
    await testVulnerabilityCheckParsing();
    await testErrorHandling();
    await testSeverityFiltering();
    await testToolAvailability();
  } catch (error) {
    console.error('‚ùå Test suite failed:', error.message);
    process.exit(1);
  }
}

main();
